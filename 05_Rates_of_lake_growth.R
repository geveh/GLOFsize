################################################################################
#######         Calculate regional rates of glacier lake growth           ######
#######                                                                   ######
#######                            by Georg Veh                           ######
#######                checked and comments added March 05, 2024          ######
#######            changed to use data from Zhang et al. (2024),          ###### 
#######                checked and comments added Dec 23, 2024            ######
################################################################################

# DISCLAIMER: This script is meant to make our findings reproducible. However,
# we do not redistribute the original lake inventories, which might be subject
# to differing licenses. Therefore, please contact the authors of the underlying
# studies to run this script.

# Load the following packages, or use install.packages("nameofpackage"), if some 
# of them are not pre-installed. In some cases you need to restart your R session.

# Important: we run brms models using the cmdstan backend. This needs to be
# installed separately using the instructions given here: 
# https://mc-stan.org/cmdstanr/ 

require(tidyverse)
require(tidybayes)
require(readODS)
require(sf)
require(gfcanalysis)
require(pbapply)
require(parallel)
require(brms)
require(scales)
require(terra)
require(ggpubr)

# Set YOUR working directory folder where to find all lake inventories, necessary 
# to run this script. Change the location appropriately.

setwd("D:/data/Zhang_glacial_lakes_global")

################################################################################
### Split lake inventories to the extent of the study regions ##################

# We split each lake inventory according the outlines of the study regions. 
# The lakes need to be within a 5-km buffer around glaciers. To this end,
# we collect the glacier buffer we generated previously.

buffer.dissolve <- readRDS("D:/data/BoxUP/Work 2022/GLOFsize/dissolved_buffer.RDS")

# buffer.dissolve <- st_read("D:/data/BoxUP/Work 2022/GLOFsize/rgi06/rgiO2_dissolved_outlines.shp")


# We then create inventories where the individual inventories should be deposited.

sapply(buffer.dissolve$FULL_NAME, function (x) {
  
  dir.create(path = paste0("D:/data/BoxUP/Published_lake_databases/Zhang_split/", 
                           x),
             recursive = ) 
})

# We list the name of the folders, as we will drop the inventories there.

out.folder.list <- paste0("D:/data/BoxUP/Published_lake_databases/Zhang_split/", 
                          buffer.dissolve$FULL_NAME)

zhang.shps <- list.files("D:/data/Zhang_glacial_lakes_global", 
                         pattern = "Glacial_lake_1990.shp$|Glacial_lake_2020.shp$",
                         recursive = T, full.names = T, include.dirs = T)

# We now iterate over all shapefiles generated by Zhang.

for (i in 1:length(zhang.shps)) {
  
  # We read the vector file, repair its geometry, and project the data to
  # WGS84 (EPSG code: 4326).
  
  sf_use_s2(TRUE)
  
  shp <- st_read(zhang.shps[i]) %>% 
    st_zm(drop = TRUE, what = "ZM") %>%
    st_make_valid() %>%
    st_transform(4326) 
  
  # We ensure that each file is a MULTIPOLYGON.
  
  if (st_geometry_type(shp, by_geometry = F) != "MULTIPOLYGON") {
    
    shp <- st_cast(x = shp , 
                   to = "MULTIPOLYGON")  
    
  }
  
  # We delete columns that have non-standard characters, as those are difficult
  # to be machine readable.
  
  shp <- shp[, grep("[^\x20-\x7F]", colnames(shp), invert = T)]

 
  sf_use_s2(FALSE)
  
  # The next step is important: we find out, which lakes intersect with the RGI 
  # buffer. We only keep lakes that are within a distance of 5 km around the
  # glaciers in the RGI V6.0 to warrant comparability across inventories.
  
  int <- st_intersects(buffer.dissolve, shp) 
  
  # We loop over RGI buffers that intersect with the lake inventories. If
  # no lake intersects with the buffer, we stop the loop.
  
  rgi.int <- which(sapply(int, function (x) !identical(x, integer(0))))
  
  if(length(rgi.int) == 0) next
  
  for (j in rgi.int) {
    
    regional.int <- st_intersects(buffer.dissolve[j, ], shp, sparse = F)[1, ]
    
    # We obtain the coordinate from a point inside the polygon. This is
    # more or less equivalent to the centroid.
    
    reg.shp <- shp[regional.int, ]
    
    reg.coords <- reg.shp %>%
      st_point_on_surface()

    # Finally, we write that information into a separate directory that
    # we created before we entered the loop.
    
    out.dir <- paste0(out.folder.list[j],  "/")
    
    # We write that vector file to disk in the same format as we had read it.
    
    if(!dir.exists(out.dir)) dir.create(out.dir)
    
    st_write(reg.shp,
             paste0(out.dir, basename(zhang.shps[i])),
             delete_layer = T,
             delete_dsn = T)
    
  }
  
  sf_use_s2(TRUE)
  
  message(paste0("File ", i, " out of ", length(zhang.shps), " processed."))
  
}

################################################################################
### Calculate the regional rate of change in total lake area between 1990 and ##
### 2020 #######################################################################

shp.files <- list.files(pattern = ".shp$", 
                        recursive = T, 
                        include.dirs = T, 
                        full.names = T)

la <- lapply(shp.files, function (x) {
    
    # We read the shapefile to memory.
    
    shp <- st_read(x) %>%
      st_drop_geometry()
    
    if(mean(shp$Year, na.rm = T) < 2010) {
     shp <- shp %>% mutate(Year_new = 1990)} else { 
       shp <-  shp %>% mutate(Year_new = 2020) }
    
    shp <- shp %>% 
      mutate(region = gsub( "./", "", dirname(x)) %>% 
                       str_replace_all("_", " "))

    
  })
  
# Generate one long dataframe with all lakes in our study regions mapped in 1990
# and 2020.

la <- do.call(rbind, la) %>%
    as_tibble()

# Obtain the regional total lake area in 1990 and 2020.

la.all <- la %>% 
  group_by(region, Year_new) %>%
  summarise(area_sum = sum(Area),
            area_error_sum = sqrt(sum(Error^2)),
            mean_year = mean(Year)) %>%
  arrange(Year_new) %>% 
  ungroup() %>% 
  arrange(region, Year_new) %>%
  mutate(Year_new = factor(Year_new))

# For each unique region, we now obtain the change in lake area, both in total
# and relative (percent) between 1990 and 2020.

uni.reg <- unique(la.all$region)

lake.change.list <- list()

for (reg in uni.reg) {
  
  region <- la.all[la.all$region == reg, ]
  region.2020 <- region[region$Year_new == 2020, ]
  region.1990 <- region[region$Year_new == 1990, ]
  
  if (nrow(region) != 0) {
    
    region.area.change <- region.2020$area_sum - region.1990$area_sum
    
    region.perc.area.change <- ((region.2020$area_sum - region.1990$area_sum) / region.1990$area_sum)*100
    
    rel.err.region.1990 <- region.1990$area_error_sum /
      region.1990$area_sum
    
    rel.err.region.2020 <- region.2020$area_error_sum /
      region.2020$area_sum
    
    annual.perc.change.region <- region.perc.area.change / 
      (region.2020$mean_year - region.1990$mean_year)
    
    perc.err.change.region <- sqrt((rel.err.region.1990^2) + (rel.err.region.2020^2)) * abs(region.perc.area.change)
    
    annual.error.change.region <- perc.err.change.region / 
      (region.2020$mean_year - region.1990$mean_year)
    
    region.tibble <- tibble(
      Region = reg,
      Area_change_total = region.area.change,
      Area_change = region.perc.area.change,
      Annual_area_change = annual.perc.change.region,
      Annual_area_change_error =  annual.error.change.region
    ) } else {
      
      region.tibble <- tibble(
        Region = reg,
        Area_change_total = region.area.change,
        Area_change = NA,
        Annual_area_change = NA,
        Annual_area_change_error = NA
      )
      
    }
  
  lake.change.list[[reg]] <- rbind(region.tibble)
  
}

# Bind these statistics to one tibble and add the units of the change statistics.
# We will use these as labels for the plot below.
# The change in area in % and in area [km²] will be added as a label.

area_change_all_stats <- do.call(rbind, lake.change.list) %>%
  mutate(region_f = factor(Region),
         Area_change_km2 = paste0(round(Area_change_total, digits = 1), " km²"),
         Annual_area_change_perc = paste0(round(Annual_area_change, digits = 2), "%"))

# We first obtain barplot-type histograms that show the total area of glacier-fed
# and ice-dammed lakes in 1990 and 2020 for each of the 13 study regions.

area_change_all <- la %>% 
  group_by(region, Year_new) %>%
  summarise(area_sum = sum(Area),
            area_error_sum = sqrt(sum(Error^2)),
            mean_year = mean(Year)) %>%
  arrange(Year_new) %>% 
  ungroup() %>% 
  arrange(region, Year_new) %>%
  mutate(Year_new = factor(Year_new),
         region_f = factor(region, 
                           levels = c("Alaska Range",
                                      "W Chugach Mountains",
                                      "Saint Elias Mountains",
                                      "Coast Ranges",
                                      "C and N Andes",
                                      "Patagonia",
                                      "Iceland",
                                      "Scandinavia",
                                      "Alps",
                                      "Hissar Alay and Tien Shan",
                                      "HK Pamir Karakoram",
                                      "Himalayas",
                                      "Tibet and Hengduan Shan"))) %>%
  ggplot(aes(x = Year_new, y = area_sum)) +
  geom_bar(stat = "identity", color = "black",
           fill = "grey20",
           position='dodge',
           width = 1) +
  facet_wrap(~region_f, scales = "free_y", ncol = 5) +
  theme_bw() +
  theme(axis.text = element_text(size = 7),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 7),
        strip.text = element_text(size = 7),
        strip.background = element_blank()) +
  geom_text(data = area_change_all_stats,
            mapping = aes(x = factor(1990), y = 0, label = Area_change_km2),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "white") +
  geom_text(data = area_change_all_stats,
            mapping = aes(x = factor(2020), y = 0, label = Annual_area_change_perc),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "white") +
  labs(x = "Year",
       y = "Total area of glacier-fed and ice-dammed lakes [km²]")

# We then do the same plot only for ice-dammed lakes.

area_change <- la %>% 
    group_by(region, Year_new, Type1) %>%
    summarise(area_sum = sum(Area),
              area_error_sum = sqrt(sum(Error^2)),
              mean_year = mean(Year)) %>%
    arrange(Year_new) %>% 
    ungroup() %>% 
    arrange(region, Year_new, Type1)

a.2020 <- area_change %>% filter(Year_new == 2020) %>% pull(area_sum)
a.1990 <- area_change %>% filter(Year_new == 1990) %>% pull(area_sum)

uni.reg <- unique(area_change$region)

glacier.fed.ice.list <- list()

for (reg in uni.reg) {
  
  region <- area_change[area_change$region == reg, ]
  
  glacier.fed.1990 <- region %>% filter(Type1 == 1, Year_new == 1990)
  glacier.fed.2020 <- region %>% filter(Type1 == 1, Year_new == 2020)
  
  if (nrow(glacier.fed.1990) != 0) {
  
  glacier.fed.perc.area.change <- ((glacier.fed.2020$area_sum - glacier.fed.1990$area_sum) / glacier.fed.1990$area_sum)*100

  rel.err.glacier.fed.1990 <- glacier.fed.1990$area_error_sum /
    glacier.fed.1990$area_sum
  
  rel.err.glacier.fed.2020 <- glacier.fed.2020$area_error_sum /
    glacier.fed.2020$area_sum
  
  annual.perc.change.glacier.fed <- glacier.fed.perc.area.change / 
    (glacier.fed.2020$mean_year - glacier.fed.1990$mean_year)
  
  perc.err.change.glacier.fed <- sqrt((rel.err.glacier.fed.1990^2) + (rel.err.glacier.fed.2020^2)) * abs(glacier.fed.perc.area.change)
  
  annual.error.change.glacier.fed <- perc.err.change.glacier.fed / 
    (glacier.fed.2020$mean_year - glacier.fed.1990$mean_year)
  
  glacier.fed.tibble <- tibble(
    Region = reg,
    Type = "glacier-fed",
    Area_change = glacier.fed.2020$area_sum - glacier.fed.1990$area_sum,
    Annual_area_change = annual.perc.change.glacier.fed,
    Annual_area_change_error =  annual.error.change.glacier.fed
  ) } else {
    
    glacier.fed.tibble <- tibble(
      Region = reg,
      Type = "glacier-fed",
      Area_change = NA,
      Annual_area_change = NA,
      Annual_area_change_error = NA
    )
      
    }
  
  ice.1990 <- region %>% filter(Type1 == 3, Year_new == 1990)
  ice.2020 <- region %>% filter(Type1 == 3, Year_new == 2020)
  
  if (nrow(ice.1990) != 0) {
    
  ice.perc.area.change <- ((ice.2020$area_sum - ice.1990$area_sum) / ice.1990$area_sum) * 100
  
  rel.err.ice.1990 <- ice.1990$area_error_sum / ice.1990$area_sum
  
  rel.err.ice.2020 <- ice.2020$area_error_sum / ice.2020$area_sum

  annual.perc.change.ice <- ice.perc.area.change / 
                             (ice.2020$mean_year - ice.1990$mean_year)
  
  perc.err.change.ice <- sqrt((rel.err.ice.1990^2) + (rel.err.ice.2020^2)) * abs(ice.perc.area.change)
  
  annual.error.change.ice <- perc.err.change.ice / 
    (ice.2020$mean_year - ice.1990$mean_year)
  
  ice.tibble <- tibble(
    Region = reg,
    Type = "ice-dammed",
    Area_change = ice.2020$area_sum - ice.1990$area_sum,
    Annual_area_change = annual.perc.change.ice,
    Annual_area_change_error =  annual.error.change.ice
  ) } else {
    
    ice.tibble <- tibble(
      Region = reg,
      Type = "ice-dammed",
      Area_change = NA,
      Annual_area_change = NA,
      Annual_area_change_error = NA
    )
    
  }

  glacier.fed.ice.list[[reg]] <- rbind(glacier.fed.tibble,
                                       ice.tibble)
  
}

glacier.fed.ice <- do.call(rbind, glacier.fed.ice.list) %>%
  mutate(region_f = factor(Region),
         Area_change_km2 = paste0(round(Area_change, digits = 1), " km²"),
         Annual_area_change_perc = paste0(round(Annual_area_change, digits = 2), "%"))

area_change_ice_dammed <- la %>% 
  filter(Type1 == 3) %>%
  group_by(region, Year_new) %>%
  summarise(area_sum = sum(Area),
            area_error_sum = sqrt(sum(Error^2)),
            mean_year = mean(Year)) %>%
  arrange(Year_new) %>% 
  ungroup() %>% 
  arrange(region, Year_new) %>%
  mutate(Year_new = factor(Year_new),
         region_f = factor(region, 
                           levels = c("Alaska Range",
                                      "W Chugach Mountains",
                                      "Saint Elias Mountains",
                                      "Coast Ranges",
                                      "C and N Andes",
                                      "Patagonia",
                                      "Iceland",
                                      "Scandinavia",
                                      "Alps",
                                      "Hissar Alay and Tien Shan",
                                      "HK Pamir Karakoram",
                                      "Himalayas",
                                      "Tibet and Hengduan Shan"))) %>%
  ggplot(aes(x = Year_new, y = area_sum)) +
  geom_bar(stat = "identity", color = "black",
           fill = "navy",
           position='dodge',
           width = 1) +
  facet_wrap(~region_f, scales = "free_y", ncol = 5) +
  theme_bw() +
  theme(axis.text = element_text(size = 7),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 7),
        strip.text = element_text(size = 7),
        strip.background = element_blank()) +
  geom_text(data = glacier.fed.ice %>% filter(Type == "ice-dammed"),
            mapping = aes(x = factor(1990), y = 0, label = Area_change_km2),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "white") +
  geom_text(data = glacier.fed.ice %>% filter(Type == "ice-dammed"),
            mapping = aes(x = factor(2020), y = 0, label = Annual_area_change_perc),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "white") +
  labs(x = "Year",
       y = "Total area of ice-dammed lakes [km²]")

# And finally, the plot for ice-dammed lakes only.

area_change_glacier_fed <- la %>% 
  filter(Type1 == 1) %>%
  group_by(region, Year_new) %>%
  summarise(area_sum = sum(Area),
            area_error_sum = sqrt(sum(Error^2)),
            mean_year = mean(Year)) %>%
  arrange(Year_new) %>% 
  ungroup() %>% 
  arrange(region, Year_new) %>%
  mutate(Year_new = factor(Year_new),
         region_f = factor(region, 
                           levels = c("Alaska Range",
                                      "W Chugach Mountains",
                                      "Saint Elias Mountains",
                                      "Coast Ranges",
                                      "C and N Andes",
                                      "Patagonia",
                                      "Iceland",
                                      "Scandinavia",
                                      "Alps",
                                      "Hissar Alay and Tien Shan",
                                      "HK Pamir Karakoram",
                                      "Himalayas",
                                      "Tibet and Hengduan Shan"))) %>%
  ggplot(aes(x = Year_new, y = area_sum)) +
  geom_bar(stat = "identity", color = "black",
           fill = "#ee7600",
           position='dodge',
           width=1) +
  facet_wrap(~region_f, scales = "free_y", ncol = 5) +
  theme_bw() +
  theme(axis.text = element_text(size = 7),
        axis.text.x = element_text(size = 7),
        axis.title = element_text(size = 7),
        strip.text = element_text(size = 7),
        strip.background = element_blank()) +
  geom_text(data = glacier.fed.ice %>% filter(Type == "glacier-fed"),
            mapping = aes(x = factor(1990), y = 0, label = Area_change_km2),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "black") +
  geom_text(data = glacier.fed.ice %>% filter(Type == "glacier-fed"),
            mapping = aes(x = factor(2020), y = 0, label = Annual_area_change_perc),
            size = 1.8,
            vjust = -1,
            hjust = 0.5,
            colour = "black") +
  labs(x = "Year",
       y = "Total area of glacier-fed lakes [km²]")


require(ggpubr)

area.change.stack <- ggarrange(area_change_all, area_change_glacier_fed, area_change_ice_dammed, 
                        labels = c("a", "b", "c"),
                        ncol = 1, nrow = 3, align = "v",
                        font.label = list(size = 10, color = "black", face = "plain", family = NULL))

ggsave(filename = "D:/data/BoxUP/Work 2022/GLOFsize/area_change.pdf",
       area.change.stack, 
       width = 160,
       height = 200,
       units = "mm")


################################################################################
### Histograms of global glacier lake area change between 1990 and 2020 ########

# As above, calculate statistics of global lake area change.

perc_area_change <- ((area_change[2, "area_sum"] - 
                          area_change[1, "area_sum"])/
                         area_change[2, "area_sum"]) *100
  
rel.err.1990 <- area_change[1, "area_error_sum"] /
    area_change[1, "area_sum"]
  
rel.err.2020 <- area_change[2, "area_error_sum"] /
    area_change[1, "area_sum"]
  
perc_error_change <- sqrt((rel.err.1990^2) + (rel.err.2020^2)) * perc_area_change
  
annual.perc.change <- perc_area_change / (area_change[2, "mean_year"] - area_change[1, "mean_year"])
annual.error.change <- perc_error_change / (area_change[2, "mean_year"] - area_change[1, "mean_year"])
  
o <- data.frame(region = "Global", 
                  area_change = perc_area_change %>% as.numeric(),
                  error_change = perc_error_change %>% as.numeric(),
                  annual_perc_area_change = annual.perc.change %>% as.numeric(),
                  annual_error_change = annual.error.change %>% as.numeric())
  

# What is the lake area smaller than 1 km²?

la.sm1 <- la %>% 
  filter(Area < 1) %>% 
  group_by(Year_new) %>% 
  summarise(area_sum = sum(Area),
            nobs = n())

# What is the lake area greater than 1 km²?

la.gt1 <- la %>% 
  filter(Area >= 1) %>% 
  group_by(Year_new) %>% 
  summarise(area_sum = sum(Area),
            nobs = n())

# What is the total lake area?

la.tot <- la %>% 
  group_by(Year_new) %>%
  summarise(area_sum = sum(Area),
            nobs = n())

la.sm1$area_frac <- round((la.sm1$area_sum / la.tot$area_sum) * 100, digits = 1)
la.sm1$nobs_frac <- round((la.sm1$nobs / la.tot$nobs) * 100, digits = 1)
la.sm1$area_frac <- round((la.sm1$area_sum / la.tot$area_sum) * 100, digits = 1)

la.gt1$area_frac <- round((la.gt1$area_sum / la.tot$area_sum) * 100, digits = 1)
la.gt1$nobs_frac <- round((la.gt1$nobs / la.tot$nobs) * 100, digits = 1)
la.gt1$area_frac <- round((la.gt1$area_sum / la.tot$area_sum) * 100, digits = 1)

# We plot a stacked histogram of lake areas in 1990 and 2020 and add the 
# number and fraction from the total below and above 1 km² as labels to the plot. 

lake.hist <- la  %>%
  mutate(log_Area = Area, 
        Year_new = factor(Year_new) %>% fct_rev()) %>% 
  ggplot( aes(x = Area, fill=Year_new)) +
  geom_histogram( color="#e9ecef", position = 'identity',
                  breaks = 10^seq(-3.5, 5, by = 0.25)) +
  scale_fill_manual(values=c("gray15", "forestgreen")) +
  ylab("Lake count per bin")  +
  xlab("Area [km²]") +
  scale_x_log10(limits = c(10^-3.5, 10^3.5),
                breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() + 
  ylim(c(0, 7000)) +
  theme( axis.text   = element_text(size = 7),
         axis.text.x = element_text(size = 7),
         axis.title  = element_text(size = 7),
         strip.text  = element_text(size = 7),
         legend.position = "none") +
  geom_vline(xintercept = 1, color = "gray30") +
  annotate(x = 10^-3.5, 
           y = 5800, 
           geom = "text",
           label = paste0("n = ", la.sm1$nobs[1], " (", la.sm1$nobs_frac[1], "%)"),
           size = 2.3,
           colour = "forestgreen",
           hjust = "left") +
  annotate(x = 10^-3.5, 
           y = 5300, 
           geom = "text",
           label = paste0("n = ", la.sm1$nobs[2], " (", la.sm1$nobs_frac[2], "%)"),
           size = 2.3,
           colour = "gray15",
           hjust = "left") +
  annotate(x = 10^3.5, 
           y = 5800, 
           geom = "text",
           label = paste0("n = ", la.gt1$nobs[1], " (", la.gt1$nobs_frac[1], "%)"),
           size = 2.3,
           colour = "forestgreen",
           hjust = "right") +
  annotate(x = 10^3.5, 
           y = 5300, 
           geom = "text",
           label = paste0("n = ", la.gt1$nobs[2], " (", la.gt1$nobs_frac[2], "%)"),
           size = 2.3,
           colour = "gray15",
           hjust = "right") 

# We add the statistics above 1 km² as a small inset to the plot.

zoom.to.gt1 <- la  %>%
  mutate(log_Area = Area, 
         Year_new = factor(Year_new) %>% fct_rev()) %>% 
  ggplot( aes(x = Area, fill=Year_new)) +
  geom_histogram( color="#e9ecef", position = 'identity',
                  breaks = 10^seq(-3.5, 5, by = 0.25)) +
  scale_fill_manual(values=c("gray15", "forestgreen")) +
  scale_x_log10(limits = c(10^0, 10^3),
                breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() + 
  theme( axis.text   = element_text(size = 6),
         axis.text.x = element_text(size = 6),
         axis.title  = element_text(size = 6),
         strip.text  = element_text(size = 6),
         axis.title.x = element_blank(),
         axis.title.y = element_blank(),
         legend.position = "none") 

ggsave(filename = "D:/data/BoxUP/Work 2022/GLOFsize/zoom_to_gt1.pdf",
       zoom.to.gt1, 
       width = 30,
       height = 20,
       units = "mm")

# Now use the same histogram layout, but change from counts to areas in each bin.

lake.area.growth.hist <- la %>%
  mutate(log_Area = Area, 
         Year_new = factor(Year_new) %>% fct_rev()) %>% 
  ggplot() +
  geom_histogram( aes(x=Area, weight=Area, fill=Year_new),
                  color="#e9ecef", position = 'identity',
                  breaks = 10^seq(-3.5, 3.5, by = 0.25)) +
  scale_fill_manual(values=c("gray15", "forestgreen")) +
  ylab("Lake area [km²] per bin")  +
  xlab("Area [km²]") +
  ylim(c(0, 1000)) +
  scale_x_log10(limits = c(10^-3.5, 10^3.5),
                breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() + 
  theme( axis.text   = element_text(size = 7),
         axis.text.x = element_text(size = 7),
         axis.title  = element_text(size = 7),
         strip.text  = element_text(size = 7),
         legend.position = "none") +
  geom_vline(xintercept = 1, color = "gray30") +
  annotate(x = 10^-3.5, 
           y = 750, 
           geom = "text",
           label = paste0("a = ", round(la.sm1$area_sum[1]), "km² (", la.sm1$area_frac[1], "%)"),
           size = 2.3,
           colour = "forestgreen",
           hjust = "left") +
  annotate(x = 10^-3.5, 
           y = 650, 
           geom = "text",
           label = paste0("a = ", round(la.sm1$area_sum[2]), " km² (", la.sm1$area_frac[2], "%)"),
           size = 2.3,
           colour = "gray15",
           hjust = "left") +
  annotate(x = 10^3.5, 
           y = 750, 
           geom = "text",
           label = paste0("a = ", round(la.gt1$area_sum[1]), " km² (", la.gt1$area_frac[1], "%)"),
           size = 2.3,
           colour = "forestgreen",
           hjust = "right") +
  annotate(x = 10^3.5, 
           y = 650, 
           geom = "text",
           label = paste0("a = ", round(la.gt1$area_sum[2]), " km² (", la.gt1$area_frac[2], "%)"),
           size = 2.3,
           colour = "gray15",
           hjust = "right") +
  annotate(x = 10^-3.5, 
           y = 550, 
           geom = "text",
           label = c(expression(Delta),  
                     paste0(": +", round(la.sm1$area_sum[2] - la.sm1$area_sum[1]), " km²")),
           size = 2.3,
           colour = "gray15",
           hjust = "left") +
  annotate(x = 10^3.5, 
           y = 550, 
           geom = "text",
           label = c(expression(Delta),  
                     paste0(": +", round(la.gt1$area_sum[2] - la.gt1$area_sum[1]), " km²")),
           size = 2.3,
           colour = "gray15",
           hjust = "right") 


# Finally, we would like to know how many lakes from all mapped lakes had a 
# reported outburst between 1990 and 2020.

# All lakes as of 2020.

shp.files.2020 <- list.files(pattern = "_2020.shp$", recursive = T, include.dirs = T, full.names = T)

la.2020 <- lapply(shp.files.2020, function (x) {
  
  # We read the shapefile to memory.
  
  shp <- st_read(x) %>%
    st_transform(4326) %>%
    st_make_valid()
  
})

la.2020 <- do.call(rbind, la.2020) 

# All lakes as of 1990.

shp.files.1990 <- list.files(pattern = "_1990.shp$", recursive = T, include.dirs = T, full.names = T)

la.1990 <- lapply(shp.files.1990, function (x) {
  
  # We read the shapefile to memory.
  
  shp <- st_read(x) %>%
    st_transform(4326) %>%
    st_make_valid()
  
})

la.1990 <- do.call(rbind, la.1990) 
  
burst.lakes <- readRDS("D:/data/BoxUP/Work 2022/GLOFsize/la_sf.RDS")
st_write(burst.lakes, "D:/data/BoxUP/Work 2022/GLOFsize/burst_lakes_1990_2023.gpkg")

# We draw a small buffer around the central coordinates of the burst lakes.

burst.lakes.buf <- burst.lakes  %>% 
  vect() %>% 
  buffer(width = 200) %>% 
  st_as_sf() 

# We intersect this buffer with the mapped lake areas in 2020.

int.burst.la <- st_intersects(la.2020, burst.lakes.buf,sparse = F)

tf <- apply(int.burst.la, MARGIN = 1, function (x) {any(x == TRUE)})

# All lakes that do not with this buffer are called 'unburst' lakes.

unburst.lakes <- la.2020[!tf, ]

max.burst.lakes <- burst.lakes %>%
  mutate(Glacier_and_lake = paste0(RGI_Glacier_Id, "_", Lake)) %>%
  group_by(Glacier_and_lake) %>%
  slice_max(Lake_area_before, na_rm = T) %>%
  mutate(Area = Lake_area_before/10^6)

max.burst.lakes %>% 
  st_drop_geometry() %>% 
  ungroup() %>% 
  filter(Area < 1) %>% 
  summarise(n()) %>% 
  pull() / nrow(max.burst.lakes)

# We now would like to know how many of the lakes in the histogram bins had
# a reported outburst.

# To this end, we define the intervals

intervals <-  10^seq(-3.5, 3.5, by = 0.25)

# Create a complete set of intervals with midpoints, even if no data points are 
# in that interval.

complete_intervals <- tibble(
  low = intervals[1 : (length(intervals)-1)],
  high = intervals[2 : length(intervals)],
  midpoint = (low + high)/2,
  unburst_lakes = 0,
  all_lakes = 0,
  ratio = NA
)

# Count occurrences within intervals and join with complete set of intervals

for(i in 1:nrow(complete_intervals)) {
  
  n.unburst <- length(which(
                (unburst.lakes$Area > (complete_intervals[i, 1] %>% pull()) &
                  unburst.lakes$Area < (complete_intervals[i, 2] %>% pull()))
                 ))
  
  n.all     <- length(which(
                (la.2020$Area > (complete_intervals[i, 1] %>% pull()) &
                  la.2020$Area < (complete_intervals[i, 2] %>% pull()))
                 ))
  

  complete_intervals$unburst_lakes[i] <- n.unburst
  complete_intervals$all_lakes[i] <- n.all
  
  complete_intervals$ratio[i] <- round((n.unburst/ n.all)*100, digits = 1)
  
}

# We also would like to know how many of all lakes smaller and larger than 1 km²
# had a GLOF.

complete_intervals <- complete_intervals %>% 
  filter(!is.nan(ratio)) %>%
  mutate(ratio_perc = paste0(ratio, "%"))

unburst.sm1 <- round((length(which(unburst.lakes$Area < 1 )) / 
                      length(which(la.2020$Area < 1 ))) * 100, digits = 1)

unburst.gt1 <- round((length(which(unburst.lakes$Area > 1 )) / 
                      length(which(la.2020$Area > 1 ))) * 100, digits = 1)

# Finally, generate the plot of reported GLOFs in each size bin.
# And add the labels of the fraction of burst lakes.

glof.hist <- max.burst.lakes %>% 
  ungroup() %>% 
  st_drop_geometry() %>% 
  dplyr::select(Area) %>%
  ggplot() +
  geom_histogram( aes(x=Area),
                  color="#e9ecef", 
                  fill ="darkslategray3",
                  breaks = 10^seq(-3.5, 3.5, by = 0.25)) +
  ylab("GLOFs per bin")  +
  xlab("Area [km²]") +
  ylim(c(0, 40)) +
  scale_x_log10(limits = c(10^-3.5, 10^3.5),
                breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  theme_bw() + 
  theme( axis.text   = element_text(size = 7),
         axis.text.x = element_text(size = 7),
         axis.title  = element_text(size = 7),
         strip.text  = element_text(size = 7),
         legend.position = "none") +
  geom_vline(xintercept = 1, color = "gray30") +
  geom_text(data = complete_intervals,
            mapping = aes(x = midpoint, y = 0.5, label = ratio_perc),
            size = 2,
            colour = "gray15",
            hjust = "left", 
            angle = 90) + 
  annotate(x = 10^-3.5, 
           y = 40, 
           geom = "text",
           label = paste0("% unburst lakes: ", unburst.sm1, "%"),
           size = 2.3,
           colour = "gray15",
           hjust = "left") + 
  annotate(x = 10^3.5, 
           y = 40, 
           geom = "text",
           label = paste0("% unburst lakes: ", unburst.gt1, "%"),
           size = 2.3,
           colour = "gray15",
           hjust = "right") 


# Stack the three histograms on top.

hist.stack <- ggarrange(lake.hist, lake.area.growth.hist, glof.hist, 
                        labels = c("a", "b", "c"),
                        ncol = 1, 
                        nrow = 3, 
                        align = "v",
                        font.label = list(size = 10, 
                                          color = "black", 
                                          face = "plain", 
                                          family = NULL))

ggsave(hist.stack, 
       filename = "D:/data/BoxUP/Work 2022/GLOFsize/histogram_stack.pdf",
       width = 80, height = 140,
       units = "mm")
